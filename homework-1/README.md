# Постановка задачи: Task Scheduler

## 1. Общая информация

Необходимо разработать модуль **планирования задач (Task Scheduler)**, предназначенный для использования в программных системах, где:

* основной прикладной код может быть написан на языке **C**;
* внутренняя реализация допускает использование **C++** для упрощения архитектуры и управления состоянием;
* требуется детерминированное выполнение периодических и одноразовых задач на основе внешнего источника времени.

Модуль должен предоставлять **C-совместимый интерфейс (C ABI)** и не раскрывать детали своей внутренней реализации.

---

## 2. Цель разработки

Целью разработки является создание универсального и переносимого планировщика задач, который:

* не зависит от операционной системы;
* не использует системные таймеры или потоки;
* может применяться в embedded‑системах, симуляторах и legacy‑проектах на C.

---

## 3. Функциональные требования

### 3.1 Управление жизненным циклом планировщика

Модуль должен предоставлять функции для:

* создания экземпляра планировщика;
* корректного освобождения всех ресурсов при его уничтожении.

Планировщик управляет собственным набором задач и их состоянием.

---

### 3.2 Управление задачами

Каждая задача должна характеризоваться следующими параметрами:

* **уникальный идентификатор** (`id`);
* **имя задачи** (строка фиксированной длины);
* **период выполнения** в миллисекундах:

  * `period_ms > 0` — периодическая задача;
  * `period_ms == 0` — одноразовая задача;
* **время следующего запуска** (`next_run_ms`).

Планировщик должен обеспечивать возможность:

* добавления новой задачи;
* удаления существующей задачи по идентификатору;
* получения информации о задаче по идентификатору;
* получения текущего количества активных задач.

---

### 3.3 Работа со временем

* Планировщик не управляет временем самостоятельно.
* Текущее время передаётся извне в виде значения `now_ms` (в миллисекундах).
* При каждом обновлении времени планировщик должен:

  * определить задачи, готовые к выполнению;
  * поместить такие задачи во внутреннюю очередь готовых задач;
  * корректно перепланировать периодические задачи;
  * удалить одноразовые задачи после их выполнения.

---

### 3.4 Очередь готовых задач

* Планировщик должен иметь внутреннюю очередь задач, готовых к выполнению.
* Внешний код должен иметь возможность:

  * извлекать готовые задачи пакетами;
  * самостоятельно выполнять извлечённые задачи;
  * не зависеть от порядка хранения задач внутри планировщика.

Планировщик не должен самостоятельно выполнять задачи.

---

## 4. Нефункциональные требования

### 4.1 Совместимость с языком C

* Публичный API должен быть полностью доступен из C‑кода.
* Интерфейс не должен использовать:

  * C++‑классы;
  * исключения;
  * шаблоны;
  * контейнеры STL.
* Доступ к планировщику осуществляется через **непрозрачные указатели**.

---

### 4.2 Детерминированность

* При одинаковом наборе задач и одинаковой последовательности вызовов результат работы планировщика должен быть идентичным.
* Порядок выдачи готовых задач должен быть стабильным и предсказуемым.

---

### 4.3 Переносимость

Модуль должен быть пригоден для использования:

* в embedded‑системах;
* в системах без операционной системы;
* в симуляторах и игровых циклах;
* в legacy‑проектах на C с постепенным внедрением C++.

---

## 5. Ограничения

* Планировщик не выполняет задачи самостоятельно.
* Планировщик не использует системные таймеры, сигналы и потоки.
* Вся синхронизация по времени осуществляется вызывающим кодом.

---

## 6. Ожидаемый результат

В результате должна быть получена реализация модуля, который:

* предоставляет C‑совместимый интерфейс для управления задачами;
* использует C++ для внутренней логики планирования;
* обеспечивает чёткое разделение ответственности:

  * планирование задач — внутри модуля;
  * выполнение задач — во внешнем коде.

---

## 7. Области применения

* Embedded‑системы и микроконтроллеры
* Периодический опрос датчиков
* Симуляторы и тестовые стенды
* Игровые циклы
* Legacy‑проекты на C с постепенной модернизацией
